package blockchain

import (
	"encoding/json"
	"github.com/smartcontractkit/chainlink/core/logger"
	"github.com/smartcontractkit/external-initiator/store"
	"github.com/smartcontractkit/external-initiator/subscriber"
	"strconv"
)

const ZIL = "zilliqa"

type zilFilterQuery struct {
	ServiceName string
	Addresses   []string
}

// The zilManager implements the subscriber.JsonManager interface and allows
// for interacting with ZIL nodes over RPC or WS.
type zilManager struct {
	fq *zilFilterQuery
	p  subscriber.Type
}

/*
Example query from: https://dev.zilliqa.com/docs/dev/dev-tools-websockets/#subscribe-event-log

{
  "query":"EventLog",
  "addresses":[
    "0x0000000000000000000000000000000000000000",
    "0x1111111111111111111111111111111111111111"
  ]
}
*/
type ZilEventLogQueryRequest struct {
	Query     string   `json:"query"`
	Addresses []string `json:"addresses"`
}

/*
Example response from:
{
   "type": "Notification",
   "values": [
      {
         "query": "EventLog",
         "value": [
            {
               "address": "afccafdc1ce8249cec35a0b432e329ce1bfac179",
               "event_logs": [
                  {
                     "_eventname": "request",
                     "params": [
                        {
                           "type": "String",
                           "value": "TEST",
                           "vname": "oracleId"
                        },
                        {
                           "type": "Uint32",
                           "value": "0",
                           "vname": "requestId"
                        },
                        {
                           "type": "ByStr20",
                           "value": "0x1a8ba23182e4686fb8121a310111d03b55c91b46",
                           "vname": "initiator"
                        },
                        {
                           "type": "String",
                           "value": "kaub",
                           "vname": "argument"
                        }
                     ]
                  }
               ]
            }
         ]
      }
   ]
}
*/

/*
{
  "jobRunID": "278c97ffadb54a5bbb93cfec5f7b5503",
  "data": {
    "symbol": "ETH-USD",
    "last": {
      "price": 467.85,
      "size": 0.01816561,
      "timestamp": 1528926483463
    }
  }
}

// Struct not used as the key value pairs are dynamic but this is the chainlink contract for external adapters.

type AutoGenerated struct {
	JobRunID string `json:"jobRunID"`
	Data     struct {
		Symbol string `json:"symbol"`
		Last   struct {
			Price     float64 `json:"price"`
			Size      float64 `json:"size"`
			Timestamp int64   `json:"timestamp"`
		} `json:"last"`
	} `json:"data"`
}
*/

type ZilEventLogQueryResponse struct {
	Type   string                  `json:"type"`
	Values []ZilEventLogQueryValue `json:"values"`
}

type ZilEventLogQueryValue struct {
	Query string `json:"query"`
	Value []struct {
		Address   string `json:"address"`
		EventLogs []struct {
			Eventname string `json:"_eventname"`
			Params    []struct {
				Type  string `json:"type"`
				Value string `json:"value"`
				Vname string `json:"vname"`
			} `json:"params"`
		} `json:"event_logs"`
	} `json:"value"`
}

// createZilManager creates a new instance of zilManager with the provided
// connection type and store.ZilSubscription config.
func createZilManager(p subscriber.Type, config store.Subscription) zilManager {
	logger.Info("Creating zil manager.")
	var addresses []string
	for _, a := range config.Zilliqa.Accounts {
		addresses = append(addresses, a)
	}
	return zilManager{
		fq: &zilFilterQuery{
			ServiceName: config.Zilliqa.ServiceName,
			Addresses:   addresses,
		},
		p: p,
	}
}

// GetTriggerJson generates a JSON payload to the ZIL node
// using the config in zilManager.
func (z zilManager) GetTriggerJson() []byte {
	logger.Infow("Getting trigger json", "ExpectsMock", ExpectsMock)

	queryCall := ZilEventLogQueryRequest{
		Query:     "EventLog",
		Addresses: z.fq.Addresses,
	}

	logger.Debug("addresses: ", z.fq.Addresses)

	switch z.p {
	case subscriber.WS:
		bytes, err := json.Marshal(queryCall)
		if err != nil {
			return nil
		}
		logger.Infow("Payload", string(bytes))
		return bytes
	default:
		logger.Errorw(ErrSubscriberType.Error(), "type", z.p)
		return nil
	}
}

// GetTestJson generates a JSON payload to test
// the connection to the ZIL node. Currently no real test message available.
//
// If zilManager is using WebSocket:
// Returns nil.
func (z zilManager) GetTestJson() []byte {
	logger.Infow("Get test json", "ExpectsMock", ExpectsMock)
	return nil
}

// ParseTestResponse parses the response from the
// ZIL node after sending GetTestJson(), and returns
// the error from parsing, if any. Currently no real test response message available.
func (z zilManager) ParseTestResponse(data []byte) error {
	logger.Infow("Parsing test response", "ExpectsMock", ExpectsMock)
	return nil
}

var numTypes = []string{"Int32", "Int128", "Int256", "Uint32", "Uint128", "Uint256"}

// ParseResponse parses the response from the
// ZIL node, and returns a slice of subscriber.Events
// and if the parsing was successful.
func (z zilManager) ParseResponse(data []byte) ([]subscriber.Event, bool) {
	logger.Infow("Parsing payload", "ExpectsMock", ExpectsMock)
	logger.Infow("Response: ", "payload", string(data))

	var msg ZilEventLogQueryResponse
	if err := json.Unmarshal(data, &msg); err != nil {
		logger.Error("failed parsing message: ", string(data))
		return nil, false
	}

	if msg.Type != "Notification" || len(msg.Values[0].Value) == 0 {
		logger.Infow("null message, skipping: ", string(data))
		return nil, false
	}

	switch z.p {
	case subscriber.WS:
		var events []subscriber.Event
		for _, v := range msg.Values {
			payload := make(map[string]interface{})
			for _, vu := range v.Value {
				for _, e := range vu.EventLogs {
					payload["type"] = v.Query
					payload["address"] = vu.Address
					payload["_eventname"] = e.Eventname
					for _, p := range e.Params {
						_, found := Find(numTypes, p.Type)
						if found {
							if i, err := strconv.Atoi(p.Value); err == nil {
								payload[p.Vname] = i
							} else {
								logger.Error("Field dropped, unknown type: ", p.Vname)
							}// skip the value
						} else {
							payload[p.Vname] = p.Value
						}
					}
				}
			}
			logger.Infow("Events: ", "Event", v)
			event, err := json.Marshal(payload)
			if err == nil {
				events = append(events, event)
			}
		}
		return events, true
	default:
		logger.Errorw(ErrSubscriberType.Error(), "type", z.p)
		return nil, false
	}
}

func Find(slice []string, val string) (int, bool) {
	for i, item := range slice {
		if item == val {
			return i, true
		}
	}
	return -1, false
}
